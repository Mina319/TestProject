# 白盒测试用例设计


语句覆盖、判定覆盖、条件覆盖、条件判定组合覆盖、多条件覆盖和修正判定条件覆盖。


## 白盒测试的概念和特点

![01-白盒测试](../../assets/突击实战项目/02/01-白盒测试.png)

白盒测试的特点：
- 优点
  - 代码覆盖率高
- 缺点
  - 覆盖所有代码路径难度大
  - 业务功能可能覆盖不全
  - 测试开销大

## 白盒测试方法的介绍

- 静态设计方法：不执行代码
  - 桌面检查：交叉检查，一个人检查
  - 代码审查：与桌面检查相比，更正式些，一般**会议**，作者讲解代码，与会人审查，关注代码结构规范
  - 代码走查：与代码审查相比，都是会议，代码走查，则是与会人提前准备测试用例，输入数据，看看数据走向，关注功能实现问题
  - 代码扫描工具：根据规则扫描代码，大大减小评审过程中、对于代码规范的时间，不能完全替代前面的3种方式  
- 动态设计方法：执行代码
  - **逻辑覆盖法**
    - 语句覆盖
    - 判定覆盖
    - 条件覆盖
    - 判定条件覆盖
    - 条件组合覆盖
    - 路径覆盖
  - **基本路径测试法**

### 逻辑覆盖法

**逻辑覆盖法**：是通过对程序逻辑结构的遍历实现程序的覆盖。

**覆盖率**：是用来度量测试完整性的一个手段。

$$ 覆盖率 = \frac{至少被执行一次的item数}{item的总数} $$

至少被执行一次的item数:覆盖的次数累加

**案例**

观察下面代码，如何对下面的代码进行覆盖测试。

```c
int logicExamle(int x, int y, int magic) {
  int A = 0;
  if(x>0 && y>0){
    A = x + y + 10;
  }else {
    A = x + y - 10;
  }
  if(magic < 0) {
    A = 0;
  }
  return A;
}
```
将代码转化为程序流程图：

![02-程序流程图](../../assets/突击实战项目/02/02-程序流程图.png)

#### 语句覆盖

语句覆盖：设计测试用例，使得程序中每条语句至少被执行一次。

$$ 语句覆盖率 = /frac {至少被执行一次的语句数量} {可执行的语句总数} $$

例如：案例代码中共有4条可执行语句，设计测试用例执行了3条，语句覆盖率为$3/4=75%$。

以刚刚的代码为案例，**语句全覆盖**（100%覆盖率），设计测试用例：

| 数据  | 语句 |
|--------|--------|
| {x=3,y=1,magic=2}  | 1、4  | 
| {x=-3,y=-1,magic=-2}  | 2、3、4  |

**局限性**

六种逻辑覆盖标准中，语句覆盖标准最弱的。

当代码写错变为`if(x>0 || y>0)`时，看流程图：

![03-程序流程图-1.png](../../assets/突击实战项目/02/03-程序流程图-1.png)

语句覆盖还是会走完所有语句，但并不能发现这个判断语句这个代码写错了。


#### 判定覆盖










## 判定覆盖法的局限性

## 条件覆盖法设计用例

## 条件覆盖的局限性

## 判定条件覆盖法的局限性

## 条件组合覆盖法设计用例

## 条件组合覆盖法的局限性

## 路径覆盖法设计用例


## 路径覆盖发的局限性

## 基本路径覆盖发设计用例

## 白盒测试用例设计方法总结
